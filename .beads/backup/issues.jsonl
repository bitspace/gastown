{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"test - cleanup","closed_at":"2026-02-24T22:01:41Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"36d42d719deb55050411461fd596be3146c80197af5a2c9a96628e9b867afcc4","created_at":"2026-02-24T22:01:34Z","created_by":"gastown/refinery","crystallizes":0,"defer_until":null,"description":"","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-0pn","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"test write","updated_at":"2026-02-24T22:01:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c26546279fe6583ee0ffdecdaa786c2782970a638c9b19d56eb859a2df1e1e2d","created_at":"2026-02-24T22:10:46Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"gt polecat nuke --force deletes both local AND remote branches. When a polecat dies before calling gt done (no MR submitted), nuking destroys the only copy of the work. Should NOT delete remote branches by default, or at minimum check if an MR bead exists first. The remote branch is the safety net for unsubmitted work. Reported by synx/witness â€” two incidents in one patrol cycle.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-4sm","is_template":0,"issue_type":"bug","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"gt polecat nuke deletes remote branches causing data loss","updated_at":"2026-02-24T22:10:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/polecats/furiosa","await_id":"","await_type":"","close_reason":"Not reproducible. Sling succeeds, dolt at 0/151 connections. Likely transient or fixed by subsequent dolt/subprocess patches.","closed_at":"2026-02-23T23:19:15Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"d1d8f328e36041e6b061582ef7acfd4dbf1d06b38b4a1b5ec20d8b1cc422a12c","created_at":"2026-02-23T00:36:00Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"gt sling fails with 'admission control: dolt server at connection capacity: capacity check failed: querying connection count: signal: killed'. The Dolt server is healthy (2 connections out of 200 max), and the same dolt sql query works fine from bash. The gt binary's subprocess is getting signal:killed consistently. This blocks ALL polecat spawns. Likely a timeout or process management issue in buildDoltSQLCmd/GetActiveConnectionCount. Dolt version 1.82.4, gt version fb0ec10c-dirty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-76k","is_template":0,"issue_type":"bug","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":0,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Admission control kills dolt sql subprocess: signal killed","updated_at":"2026-02-23T23:19:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:44:55Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-026x","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:44:55Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:47:29Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-0bnh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:47:29Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-0bya","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:33Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-0r2j","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:52:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:46:14Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-0shw","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:46:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:55:08Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-17vd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:55:08Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:43:53Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-1dzm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:43:53Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:46:40Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-1u2j","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:46:40Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:51Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-20vx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:52:51Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:53:50Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-26en","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:53:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:50:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-2a4f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:50:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:14Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-2lha","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:52:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-3acg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-4haw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:49:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:14Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-57u5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:49:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:26Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-5nru","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:54:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:57Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-5wv7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:52:57Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:08Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-65po","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:49:08Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:47:37Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-8384","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:47:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:46Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-9tkd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:52:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-9uu6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:46:48Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-alae","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:46:48Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-bkcm","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:46:58Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-boeq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:46:58Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-cch3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:54:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-dicz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:45:05Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-dipd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:45:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:47:21Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-dw45","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:47:21Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-dyod","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:47:11Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-ecwb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:47:11Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:02Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-eewq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:49:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:50:37Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-eq2t","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:50:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:23Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-fkgs","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-fv0d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:49:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:39Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-g14p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:52:39Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:16Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-glhp","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:54:16Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:44:10Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-iphs","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:44:10Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:53:12Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-irfn","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:53:12Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:55:04Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-k8bz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:55:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:52:14Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-ks1p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:52:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:44:37Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-kwx9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:44:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:50:37Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-llxq","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:50:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:53:09Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-m4zp","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:53:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:47:43Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-mrce","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:47:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-mrvl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T18:19:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:44:47Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-mtyb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:44:47Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-nbcu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:51:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:48:27Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-nl3w","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:48:27Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:23Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-nqan","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:51:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:18Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-o5is","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-24T22:51:18Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-oi18","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-24T22:54:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:53:50Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-oxyr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:53:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:49:27Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-oz4p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:49:27Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:12Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-phs2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:51:12Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:06Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-qhix","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:54:06Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:48:27Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:46:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-r6f1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:48:27Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:51Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-r7il","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:54:51Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:51Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-rc45","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-24T22:54:51Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:53:03Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-24T22:52:21Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-sir5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-24T22:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:05Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-t7px","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:51:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:55:14Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-tuhn","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:55:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:45:11Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-uthj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:45:11Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:45:58Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-uwuz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-24T22:45:58Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:36Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-v8k6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-24T22:51:36Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:44:21Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-24T22:43:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-whg2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-24T22:44:21Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:48:55Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-wsmw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-24T22:48:55Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:51:39Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:50:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-xaqz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:51:39Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:48:49Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:48:36Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-xhqw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:48:49Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-xjto","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-24T22:54:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-24T22:54:03Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-02-24T22:53:53Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-mol-z56i","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-24T22:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"ca93c127059b256765e921e5554b6dd748d31217845be82698fe3968262e18d4","created_at":"2026-02-24T00:27:50Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Observed twice on ch-xd5 (chisel rig): polecat completes work, closes the bead, worktree gets nuked, but the refinery never merges the branch to main. Convoy reports complete, bead is closed with notes showing work was done (17 integration tests), but git log main shows nothing landed. Branch is deleted during nuke. The race condition is: polecat close â†’ nuke â†’ branch gone, before refinery picks up the MR. First attempt lost commit 90bab80, second attempt also lost. Needs a gate: worktree nuke must wait for refinery merge confirmation, or branch must be preserved until merge lands.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-ph8","is_template":0,"issue_type":"bug","last_activity":null,"metadata":"{}","mol_type":"","notes":"Third attempt with --no-merge also lost the branch. Polecat cleanup does not respect --no-merge flag â€” worktree and branch both nuked before any merge. This is not a race with refinery; the nuke is unconditional.","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Polecat worktree nuked before refinery merges â€” work lost","updated_at":"2026-02-24T00:32:55Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"d4ba1cb073481d18597119e9458732d969057ad472771a28b8c614a69955ead6","created_at":"2026-02-23T23:11:08Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Rig identity bead for gastown.\n\nrepo: git@github.com:bitspace/gastown.git\nprefix: gt\nstate: active","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-rig-gastown","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"gastown","updated_at":"2026-02-23T23:11:08Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e61d5e93904182c89194eb9311ddf6a4549ffade11b13ec35ed382a78341d018","created_at":"2026-02-23T23:57:30Z","created_by":"tmux/refinery","crystallizes":0,"defer_until":null,"description":"","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-tmux-refinery","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":3,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"tmux refinery agent","updated_at":"2026-02-23T23:57:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"working","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":"2026-02-23T23:30:56Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f2261aaae7ee711ebcb39ac314050b3183555f1bedfcf70fd37deaf76fea71c0","created_at":"2026-02-23T23:18:47Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"gt-gastown-polecat-furiosa\n\nrole_type: polecat\nrig: gastown\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-gastown-polecat-furiosa","is_template":0,"issue_type":"agent","last_activity":"2026-02-23T23:19:14Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"gt-gastown-polecat-furiosa","updated_at":"2026-02-26T18:35:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5251e538025a78b3d0c39b6a9903bea4648de2085a39f36d39ced1ae23c2b7f6","created_at":"2026-02-23T23:11:04Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Refinery for gastown - processes merge queue.\n\nrole_type: refinery\nrig: gastown\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-gastown-refinery","is_template":0,"issue_type":"agent","last_activity":"2026-02-24T23:27:25Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Refinery for gastown - processes merge queue.","updated_at":"2026-02-26T18:35:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"ef8cfbb4a1f97debc88db23d1d26f9f18264c5f9103321c72978340371ccd756","created_at":"2026-02-23T23:11:04Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Witness for gastown - monitors polecat health and progress.\n\nrole_type: witness\nrig: gastown\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-gastown-witness","is_template":0,"issue_type":"agent","last_activity":"2026-03-01T09:57:54Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"chris@bitspace.org","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Witness for gastown - monitors polecat health and progress.","updated_at":"2026-03-01T09:57:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" â€” skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-14uk","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/refinery","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to their effective target branches one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   â”‚                          â”‚                           â”‚\n   â”‚ MERGE_READY              â”‚                           â”‚\n   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\u003eâ”‚                           â”‚\n   â”‚                          â”‚                           â”‚\n   â”‚                    (verify branch)                   â”‚\n   â”‚                          â”‚ fetch \u0026 rebase            â”‚\n   â”‚                          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\u003eâ”‚\n   â”‚                          â”‚                           â”‚\n   â”‚                    (run tests)                       â”‚\n   â”‚                          â”‚                           â”‚\n   â”‚                    (if pass)                         â”‚\n   â”‚                          â”‚ merge \u0026 push              â”‚\n   â”‚                          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\u003eâ”‚\n   â”‚                          â”‚                           â”‚\n   â”‚ MERGED                   â”‚                           â”‚\n   â”‚\u003câ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                           â”‚\n   â”‚                          â”‚                           â”‚\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).\n\n## CRITICAL: Read Step Instructions Before Acting\n\nBefore executing ANY step, you MUST run `bd show \u003cstep-id\u003e` and read the full\ndescription. Steps contain **Config:** values that override default behavior.\nIf a config says to skip, you skip. If it specifies a command, you use that\nexact command â€” not your own assumption. Do NOT guess what a step requires\nbased on the step title or your role knowledge. The step description is the\nsource of truth.\n\n## Variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| wisp_type | patrol | Type of wisp created for this molecule |\n| integration_branch_refinery_enabled | true | Whether refinery merges to integration branches |\n| integration_branch_auto_land | false | Whether to auto-land integration branches when epic children all closed |\n| run_tests | true | Whether to run tests before merging |\n| setup_command | (empty) | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | (empty) | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| lint_command | (empty) | Lint command (e.g., `eslint .`). Empty = skip. |\n| test_command | go test ./... | Test command to run (if run_tests is true) |\n| build_command | (empty) | Build command (e.g., `go build ./...`). Empty = skip. |\n| target_branch | main | Default target branch for merges |\n| delete_merged_branches | true | Whether to delete source branches after merge |\n\n## Target Resolution Rule\n\nWhen instructions reference `\u003crebase-target\u003e`, `\u003cmerge-target\u003e`, or `\u003cverification-target\u003e`,\nresolve that placeholder with this rule:\n\n- If integration_branch_refinery_enabled = \"true\": use MR target when present, otherwise main.\n- If integration_branch_refinery_enabled = \"false\": always use main.\n\n## FORBIDDEN Actions\n\n- FORBIDDEN: Landing integration branches to the default branch via raw git commands (`git merge`, `git push`).\n  Integration branches may ONLY be landed via `gt mq integration land \u003cepic-id\u003e`.\n  This applies regardless of `auto_land` configuration. The pre-push hook enforces this.\n\n## Step Execution Order\n\nYou MUST process steps in strict DAG order. Walk through each step sequentially,\nunless you are explicitly told to skip to a step.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-3kuw","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/refinery","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dd32257b77ec831ec7c7dff31e550834ced88e609f1a39b380623cfd69be6184","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` â€” from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` â€” from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` â€” from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again â€” conditions change)\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-refinery-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/refinery\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If you decide to hand off:**\n\nSquash wisp with summary digest, then use `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` â€” it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-6mri","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-03-01T09:55:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:55:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"443af4384cd1045acdbda933a4050db97df8d51b1eec0ff6d98d3cb78a262673","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke \u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-70p2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-03-01T09:55:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:56:42Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"20c946a4ce607e95d1778e920aba9bc020e8dd2facf1e29e6639d427646e51a9","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle â†’ archive\n- POLECAT_DONE that was auto-nuked â†’ should be archived already\n- MERGED notifications â†’ archive after acknowledging\n- HELP/Blocked that was escalated â†’ archive\n- SWARM_START that created tracking wisp â†’ archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending â†’ Needs investigation in process-cleanups\n- state:merge-requested â†’ Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-7jie","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-03-01T09:56:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"67f79c1bd91aa9b1c66af791ddc7c6ac99ccd44ccdf7d3e22b93d4766aa92147","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle:      created â†’ queued â†’ processed â†’ merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear)\n\n```\ninbox-check â”€â–º process-cleanups â”€â–º check-refinery â”€â–º survey-workers\n                                                            â”‚\n         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â–¼\n  check-timer-gates â”€â–º check-swarm â”€â–º patrol-cleanup â”€â–º context-check â”€â–º loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-7voh","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-03-01T09:54:51Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b9eb28b279f8e3dc67084dbcbb53a75ceb91f7af2c33ccd92b28a5c7484259","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\nâš ï¸ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Close MR Bead (REQUIRED - DO THIS IMMEDIATELY)**\n\nâš ï¸ **VERIFICATION BEFORE CLOSING**: Confirm the work is actually on the merge target:\n```bash\n# Get the commit message/issue from the branch\ngit log origin/\u003cmerge-target\u003e --oneline | grep \"\u003cissue-id\u003e\"\n# OR verify the commit SHA is on the target:\ngit branch --contains \u003ccommit-sha\u003e | grep \u003cmerge-target\u003e\n```\n\nIf work is NOT on the merge target, DO NOT close the MR bead. Investigate first.\n\n```bash\nbd close \u003cmr-bead-id\u003e --reason \"Merged to \u003cmerge-target\u003e at $(git rev-parse --short HEAD)\"\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\n**VALIDATION**: The MR bead's source_issue should be a valid bead ID (gt-xxxxx),\nnot a branch name. If source_issue contains a branch name, flag for investigation.\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup (only after Steps 2-4 confirmed)**\n```bash\ngit branch -d temp\n```\n\ndelete_merged_branches (see config above) controls whether to delete the remote source branch.\n\nIf delete_merged_branches is \"true\":\n```bash\ngit push origin --delete \u003cpolecat-branch\u003e\n```\n\nIf delete_merged_branches is \"false\": Leave the remote branch intact.\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] MR bead closed\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-hd78","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9508fdbbc440c7e4398e6538ca03f559df24d9fe2c4f2f0cccdddad6442d30a8","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-hkao","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:55:51Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue â€” there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\nâš ï¸ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-ibde","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-03-01T09:55:51Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:56:34Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-iik3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-03-01T09:56:34Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:56:15Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5309e2d88cf1e2e1e3f020f97fd55dd20a636678dc7fb97021127478a3867b9c","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION â€” Cross-reference tmux session existence**\n\nðŸš¨ **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Auto-nuke immediately.\n```bash\ngt polecat nuke \u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity â†’ making progress\n- Idle at prompt â†’ may need nudge\n- Error messages â†’ may need help\n\n**Step 3a: For idle polecats, auto-nuke if clean**\n\nWhen agent_state=idle, the polecat has no work assigned. Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/\u003cname\u003e\ngit status --porcelain         # Should be empty (clean)\ngit log @{u}..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke \u003cname\u003e\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE â€” handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke \u003cname\u003e  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie â€” the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION â€” Scan from beads side**\n\nðŸš¨ **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing â†’ orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead â†’ skip (zombie detection handles it)\n6. If session alive â†’ not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-j9j7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-03-01T09:56:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-mjc5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:56:24Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-p3j7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-03-01T09:56:24Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:55:04Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bc20e28055ff06a6ada8d594e1b1d5b448339523881c2a8fead75c8d4b76115b","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning â†’ working â†’ mr_submitted â†’ nuked\nMR lifecycle: created â†’ queued â†’ processed â†’ merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke \u003cname\u003e â†’ archive mail\n# - For dirty state: create wisp â†’ process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke \u003cname\u003e\n\n# Burn the cleanup wisp\nbd close \u003cwisp-id\u003e\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-scm2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-03-01T09:55:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-u2y0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"54eee5523b4bcf4f47b39fb7edaf3ffcbb9e8257fe228009806179870a303e6d","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error â€” verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error â€” manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\ngt mol squash --jitter 10s --summary \"\u003cpatrol-summary\u003e\"\n```\n3. Create and hook a new patrol wisp:\n```bash\nNEW_WISP=$(bd mol wisp mol-witness-patrol --json | jq -r '.new_epic_id')\nbd update \"$NEW_WISP\" --status=hooked --assignee=\u003crig\u003e/witness\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-v1uu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-03-01T09:56:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"4075f518aee90fe432a71bb867d21eb597313cc89b5d86b344f6db5836b3b8c7","created_at":"2026-03-01T09:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - File a bead: bd create --type=bug --priority=1 --title=\"...\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-vv51","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-03-01T09:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"gastown/witness","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-03-01T09:56:47Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-03-01T09:54:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"gt-wisp-zom3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-03-01T09:56:47Z","waiters":"","wisp_type":"","work_type":""}
